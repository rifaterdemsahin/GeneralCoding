# 5.2 Big O Analysis: Ocean View Buildings Problem

## 🎯 Problem Summary
**Ocean View Buildings**: Given array of building heights, find which buildings can see the ocean (all buildings to their right are shorter).

**Reference Implementation**: `/Users/rifaterdemsahin/projects/GeneralCoding/6_🔣_Symbols/QuestionBuildings/`

## 📊 Algorithm Analysis

### Algorithm 1: Brute Force (Basic Approach)
```csharp
public bool CanSeeOcean(List<Building> allBuildings)
{
    var buildingsToRight = allBuildings.Where(b => b.Index > this.Index);
    return buildingsToRight.All(b => b.Height < this.Height);
}
```

**Big O Analysis:**
- **Time Complexity**: `O(n²)`
  - Outer loop: n buildings to check
  - Inner operation: For each building, check all buildings to the right
  - Worst case: Building 0 checks (n-1) buildings, Building 1 checks (n-2), etc.
  - Total operations: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2 → **O(n²)**

- **Space Complexity**: `O(k)` where k = buildings with ocean view
  - Only stores result indices
  - In worst case (decreasing heights): O(n)

**Mathematical Breakdown:**
```
T(n) = Σ(i=1 to n) (n-i) = Σ(j=0 to n-1) j = (n-1)n/2 ∈ O(n²)
```

### Algorithm 2: Optimized (Right-to-Left Scan)
```csharp
public List<int> FindOceanViewBuildingsOptimized(int[] buildingHeights)
{
    var result = new List<int>();
    int maxHeightFromRight = 0;
    
    for (int i = buildingHeights.Length - 1; i >= 0; i--)
    {
        if (buildingHeights[i] > maxHeightFromRight)
        {
            result.Add(i);
            maxHeightFromRight = buildingHeights[i];
        }
    }
    result.Reverse();
    return result;
}
```

**Big O Analysis:**
- **Time Complexity**: `O(n)`
  - Single pass from right to left: n iterations
  - Each iteration: O(1) constant operations
  - Reverse operation: O(k) where k ≤ n
  - Total: O(n) + O(k) = **O(n)**

- **Space Complexity**: `O(k)` where k = buildings with ocean view
  - Same as basic approach - only stores result

**Mathematical Breakdown:**
```
T(n) = n + k ≤ n + n = 2n ∈ O(n)
```

## 🔢 Performance Comparison

### Theoretical Analysis
| Input Size (n) | Basic O(n²) Operations | Optimized O(n) Operations | Speedup Ratio |
|----------------|------------------------|---------------------------|---------------|
| 10             | ~50                    | 10                        | 5x            |
| 100            | ~5,000                 | 100                       | 50x           |
| 1,000          | ~500,000               | 1,000                     | 500x          |
| 10,000         | ~50,000,000            | 10,000                    | 5,000x        |

### Actual Measured Performance
**Test Input**: `[5, 3, 2, 4, 1]` (n=5)
- **Basic Algorithm**: `3,834,209 ticks`
- **Optimized Algorithm**: `1,250 ticks`
- **Actual Speedup**: `3,067x faster`

## 📈 Complexity Growth Rates

### Time Complexity Comparison
```
n=5:    Basic: 25 ops     vs  Optimized: 5 ops     (5x faster)
n=10:   Basic: 100 ops    vs  Optimized: 10 ops    (10x faster)
n=100:  Basic: 10,000 ops vs  Optimized: 100 ops   (100x faster)
n=1000: Basic: 1M ops     vs  Optimized: 1,000 ops (1,000x faster)
```

### Visual Growth Pattern
```
Operations
    │
    │     ╭─── O(n²) - Quadratic
    │    ╱
    │   ╱
    │  ╱
    │ ╱
    │╱_________ O(n) - Linear
    └─────────────────────────► Input Size (n)
```

## 🎯 Key Insights

### Why O(n²) → O(n) Transformation Works
1. **Observation**: We only need to track the maximum height seen from the right
2. **Key Insight**: If a building is shorter than any building to its right, it cannot see the ocean
3. **Optimization**: Single pass eliminates redundant comparisons

### Algorithm Trade-offs
| Aspect | Basic O(n²) | Optimized O(n) |
|--------|-------------|----------------|
| **Readability** | High - intuitive logic | Medium - requires insight |
| **Space Usage** | O(k) | O(k) - same |
| **Time Performance** | Poor for large inputs | Excellent scalability |
| **Implementation** | Straightforward | Requires reverse iteration |

## 🧮 Big O Classification

### Time Complexity Hierarchy
```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ)
                          ↑                    ↑
                   Optimized                Basic
```

### Real-World Impact
- **Small datasets (n < 100)**: Difference negligible
- **Medium datasets (n = 1,000)**: 1000x performance difference
- **Large datasets (n = 10,000+)**: Basic algorithm becomes unusable

## 📝 Summary

**Ocean View Buildings Problem Complexity:**
- **Brute Force**: O(n²) time, O(k) space
- **Optimized**: O(n) time, O(k) space
- **Performance Gain**: Up to n times faster
- **Scalability**: Linear vs quadratic growth
- **Best Choice**: Always use O(n) optimized approach for production code

The optimization demonstrates a fundamental algorithmic principle: **avoiding redundant work through strategic data tracking can dramatically improve performance**.
