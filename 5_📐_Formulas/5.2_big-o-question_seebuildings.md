# 5.2 Big O Analysis: Ocean View Buildings Problem

## ðŸŽ¯ Problem Summary
**Ocean View Buildings**: Given array of building heights, find which buildings can see the ocean (all buildings to their right are shorter).

**Reference Implementation**: `/Users/rifaterdemsahin/projects/GeneralCoding/6_ðŸ”£_Symbols/QuestionBuildings/`

## ðŸ“Š Algorithm Analysis

### Algorithm 1: Brute Force (Basic Approach)
```csharp
public bool CanSeeOcean(List<Building> allBuildings)
{
    var buildingsToRight = allBuildings.Where(b => b.Index > this.Index);
    return buildingsToRight.All(b => b.Height < this.Height);
}
```

**Big O Analysis:**
- **Time Complexity**: `O(nÂ²)`
  - Outer loop: n buildings to check
  - Inner operation: For each building, check all buildings to the right
  - Worst case: Building 0 checks (n-1) buildings, Building 1 checks (n-2), etc.
  - Total operations: (n-1) + (n-2) + ... + 1 = n(n-1)/2 â‰ˆ nÂ²/2 â†’ **O(nÂ²)**

- **Space Complexity**: `O(k)` where k = buildings with ocean view
  - Only stores result indices
  - In worst case (decreasing heights): O(n)

**Mathematical Breakdown:**
```
T(n) = Î£(i=1 to n) (n-i) = Î£(j=0 to n-1) j = (n-1)n/2 âˆˆ O(nÂ²)
```

### Algorithm 2: Optimized (Right-to-Left Scan)
```csharp
public List<int> FindOceanViewBuildingsOptimized(int[] buildingHeights)
{
    var result = new List<int>();
    int maxHeightFromRight = 0;
    
    for (int i = buildingHeights.Length - 1; i >= 0; i--)
    {
        if (buildingHeights[i] > maxHeightFromRight)
        {
            result.Add(i);
            maxHeightFromRight = buildingHeights[i];
        }
    }
    result.Reverse();
    return result;
}
```

**Big O Analysis:**
- **Time Complexity**: `O(n)`
  - Single pass from right to left: n iterations
  - Each iteration: O(1) constant operations
  - Reverse operation: O(k) where k â‰¤ n
  - Total: O(n) + O(k) = **O(n)**

- **Space Complexity**: `O(k)` where k = buildings with ocean view
  - Same as basic approach - only stores result

**Mathematical Breakdown:**
```
T(n) = n + k â‰¤ n + n = 2n âˆˆ O(n)
```

## ðŸ”¢ Performance Comparison

### Theoretical Analysis
| Input Size (n) | Basic O(nÂ²) Operations | Optimized O(n) Operations | Speedup Ratio |
|----------------|------------------------|---------------------------|---------------|
| 10             | ~50                    | 10                        | 5x            |
| 100            | ~5,000                 | 100                       | 50x           |
| 1,000          | ~500,000               | 1,000                     | 500x          |
| 10,000         | ~50,000,000            | 10,000                    | 5,000x        |

### Actual Measured Performance
**Test Input**: `[5, 3, 2, 4, 1]` (n=5)
- **Basic Algorithm**: `3,834,209 ticks`
- **Optimized Algorithm**: `1,250 ticks`
- **Actual Speedup**: `3,067x faster`

## ðŸ“ˆ Complexity Growth Rates

### Time Complexity Comparison
```
n=5:    Basic: 25 ops     vs  Optimized: 5 ops     (5x faster)
n=10:   Basic: 100 ops    vs  Optimized: 10 ops    (10x faster)
n=100:  Basic: 10,000 ops vs  Optimized: 100 ops   (100x faster)
n=1000: Basic: 1M ops     vs  Optimized: 1,000 ops (1,000x faster)
```

### Visual Growth Pattern
```
Operations
    â”‚
    â”‚     â•­â”€â”€â”€ O(nÂ²) - Quadratic
    â”‚    â•±
    â”‚   â•±
    â”‚  â•±
    â”‚ â•±
    â”‚â•±_________ O(n) - Linear
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Input Size (n)
```

## ðŸŽ¯ Key Insights

### Why O(nÂ²) â†’ O(n) Transformation Works
1. **Observation**: We only need to track the maximum height seen from the right
2. **Key Insight**: If a building is shorter than any building to its right, it cannot see the ocean
3. **Optimization**: Single pass eliminates redundant comparisons

### Algorithm Trade-offs
| Aspect | Basic O(nÂ²) | Optimized O(n) |
|--------|-------------|----------------|
| **Readability** | High - intuitive logic | Medium - requires insight |
| **Space Usage** | O(k) | O(k) - same |
| **Time Performance** | Poor for large inputs | Excellent scalability |
| **Implementation** | Straightforward | Requires reverse iteration |

## ðŸ§® Big O Classification

### Time Complexity Hierarchy
```
O(1) < O(log n) < O(n) < O(n log n) < O(nÂ²) < O(nÂ³) < O(2â¿)
                          â†‘                    â†‘
                   Optimized                Basic
```

### Real-World Impact
- **Small datasets (n < 100)**: Difference negligible
- **Medium datasets (n = 1,000)**: 1000x performance difference
- **Large datasets (n = 10,000+)**: Basic algorithm becomes unusable

## ðŸ“ Summary

**Ocean View Buildings Problem Complexity:**
- **Brute Force**: O(nÂ²) time, O(k) space
- **Optimized**: O(n) time, O(k) space
- **Performance Gain**: Up to n times faster
- **Scalability**: Linear vs quadratic growth
- **Best Choice**: Always use O(n) optimized approach for production code

The optimization demonstrates a fundamental algorithmic principle: **avoiding redundant work through strategic data tracking can dramatically improve performance**.
